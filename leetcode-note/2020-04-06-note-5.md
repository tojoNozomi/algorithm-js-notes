# LeetCode笔记

## 【2020.04.06】  945. 使数组唯一的最小增量

- 给定整数数组 A，每次 *move* 操作将会选择任意 `A[i]`，并将其递增 `1`。

  返回使 `A` 中的每个值都是唯一的最少操作次数。

**示例1:** 

```
输入：[1,2,2]
输出：1
解释：经过一次 move 操作，数组将变为 [1, 2, 3]。
```

**示例 2:**

```
输入：[3,2,1,2,1,7]
输出：6
解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。
可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。
```

**提示：**

1. `0 <= A.length <= 40000`
2. `0 <= A[i] < 40000`

***

这题最简单的话，就是先排序，然后再确保每个数都比前面的数大。这里的确保怎么做呢？

比如当前的数字比前一个数大，那么不用动；如果比前一个数字小的话，就加到比前面一个数大1，统计变量里加上中间的变化`A[i-1] - A[i] + 1 `，这么遍历一边就行了。当然这方法比较耗时间，多了排序这一步。

下面这种算法的话，则是基于哈希表的线性探查法。讲道理的话直接用线性探查法也能做，不过就是比较费时。那么怎么优化呢？这个时候可以使用**路径压缩**的思想。

简单来讲，就是把已探明的路径给记录下来，比如本次探查中，`A[i]`在哈希表里面offset了n次之后插入（也就是基于原有的值加上n），在探查表里面就记录下`A[i]`对应的值为`A[i] + n`，那么下次遇到和`A[i]`相同的值的时候，就从`A[i] + n`的下一位开始探查，节省了已探明部分的重复搜索时间。

实现上使用了迭代来探查，这样比不使用迭代要好实现不少。

***

```
执行结果： 通过
执行用时 : 108 ms, 在所有 JavaScript 提交中击败了93.49%的用户
内存消耗 : 41.4 MB
```

```javascript
/**
 * @param {number[]} A
 * @return {number}
 */
var minIncrementForUnique = function(A) {
    var move = 0
    var table = []
    function findPos (a) {
        b = table[a] !== undefined ? table[a] : -1
        if (b === -1) {
            table[a] = a
            return a
        }
        b = findPos(b + 1)
        table[a] = b
        return b
    }
    for (var i = 0; i < A.length; i++) {
        var distance = findPos(A[i])
        move += distance - A[i]
    }
    return move
};
```


