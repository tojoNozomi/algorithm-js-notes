# LeetCode笔记

## 【2020.03.14】  300. 最长上升子序列

给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:
```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```
说明:

可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n2) 。

进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?

*** 

这道题，上手是知道用DP，但是完全不知道DP的状态方程怎么设计orz

看答案吧：

1、先定义一个数组用于存储各个子问题的解

2、定义子问题： 要求出当前序列中的最长上升序列，也就是在前一个子问题中的nums（也就是0到i-1的范围里）数组中去遍历，找出比当前数字nums[i]要小的个数，然后写到存储解的数组中

3、上面遍历完了之后就找出存储子问题解中最大的数字输出即可。

（像[10,9,6,7,8,1,2,3,4,5],会获得[1,1,1,2,3,1,2,3,4,5], 不用担心后面比较长的序列没计算到）

时间复杂度O(n^2) 空间复杂度O(n)

当然还有其他解法： 贪心+二分查找

由于想要让上升序列尽可能地长，就需要让上升序列上升地尽可能慢。

1、设计一个数组d[]用于存储最长上升子序列，并且维护一个表示最长上升子序列的长度的变量len

2、可以注意到这个数组d是单调递增的，当遍历到i时，如果numsi大于di时，numsi直接加到di的后面。否则在di中找到第一个比numsi小的值，替换了。（因为数组d单调递增，已排序的，可以用二分法）

另外数组d中用来存储的序列并不是真实的序列，只是数量上刚好相等。因为数量相等所以不会出现记录不到的请求（比如上面的序列）一个个替换，到超出原先序列的顺序后会直接加在后面，也会更新长度

思路上和之前的《面试题59 -II 队列的最大值》有点像，可以思考下关联性？




***

```
执行结果： 通过
执行用时 : 72 ms, 在所有 JavaScript 提交中击败了81.06%的用户
内存消耗 : 34.6 MB, 在所有 JavaScript 提交中击败了62.35%的用户
```

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
    if (nums.length === 0) {
        return 0
    }
    let box = []
    let max = 0
    for (var i = 0; i < nums.length; i++) {
        box[i] = 1
        for (var j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                box[i] = Math.max(box[j] + 1, box[i])
            }
        }
        max = Math.max(box[i], max)
    }
    return max
};
```


