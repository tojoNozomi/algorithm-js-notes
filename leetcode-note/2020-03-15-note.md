# LeetCode笔记

## 【2020.03.15】  695. 岛屿的最大面积

给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)

示例 1:
```
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
```
对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。

示例 2:
```
[[0,0,0,0,0,0,0,0]]
```
对于上面这个给定的矩阵, 返回 0。

注意: 给定的矩阵grid 的长度和宽度都不超过 50。

*** 

学习了，原来这个叫沉岛思想。简单来讲就是将统计过的部分设置为不可再统计（这里就是直接置0了），和图的遍历中是差不多的。像我下面的解答就是用的深度优先的策略。

边界（小于0或者大于length - 1）的话，要注意遇到的话就直接终止并返回0了。不然就直接栈溢出了。这里的沉岛思想主要体现在： 为了确保矩阵中所有点能被遍历到，并且不会被重复计算，当遍历到grid[i][j]为1时，把grid[i][j]置为0，然后返回本身的面积并继续其他搜索。

当然还有结合栈的深度优先的做法，也有广度优先的做法。

***

```
执行结果： 通过
执行用时 : 88 ms, 在所有 JavaScript 提交中击败了77.22%的用户
内存消耗 : 35.9 MB, 在所有 JavaScript 提交中击败了100.00%的用户
```

```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */

const getArea = (grid, i, j) => {
    if (i < 0 || j < 0 || i === grid.length || j === grid[0].length) {
        return 0
    }
    if (grid[i][j] === 1) {
        grid[i][j] = 0
        return 1 + getArea(grid, i - 1, j) + getArea(grid, i + 1, j) + getArea(grid, i, j - 1) + getArea(grid, i, j + 1)
    }
    return 0
}
var maxAreaOfIsland = function(grid) {
    var area = 0
    var maxArea = 0
    for (var i = 0; i < grid.length; i++) {
        for(var j = 0; j < grid[0].length; j++) {
            area = getArea(grid, i, j)
            maxArea = area > maxArea ? area : maxArea
        }
    }
    return maxArea
};
```


