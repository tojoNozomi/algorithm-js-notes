# LeetCode笔记

## 【2020.03.09】  121. 买卖股票的最佳时机

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

示例 1:
```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
```
示例 2:
```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```


*** 
 每日打卡题居然整了一个简单的题，还行

 这题一眼看起来挺简单的，我上来就是这么想的：

 1. 首先要找出最小值，并且缓存起来

 2. 在上面找最小值遍历的时候，要顺带找最大值并缓存起来，如果当次遍历中遇到新的最小值，那么最大值要重置为最小值

 3. 最后输出最大值减去最小值

不过跑了下，有几个测试用例过不去，看起来像是缺少一些约束条件了

直接看答案：

1. 第一步和我思路一样，是缓存最小值
2. 在上面的遍历中，要顺带计算当天减去当前最小值卖出的价格，如果比上次遍历的卖出价要高，就记录起来
3. 输入最大卖出价

这题是利用了动态规划的思路（虽然我完全没意识到orz）来解题的，题本身不难，但是要注意仔细读题orz

我没看清楚要输出啥就直接开始动手了emmm这可是坏习惯

不过今天有意识地控制时间，还行。

最后再看一下别人的题解，贴个非常透彻的解析上来，这思路可太清晰了

> DP (dynamic programming)
>
> DP的思路： 利用原问题与子问题的关系，将其变成 大问题的解 = 小问题的解的函数， 从而将问题变成size的扩展即可，当size到达最大后，原问题解决了
>
> DP的keypoint
>
> 1. 转移方程（大问题与小问题的关系）
>
>```
> 1）定义状态：定义一个状态，例如f(i) = 到a[i]为止到最小值
> 2）设计转移方程：根据如上状态方程定义，则有 f(i+1) = min(f(i), a[i+1])
> 
> tip:
> 转移方程的设计完全依赖于状态的定义，并不是什么样的状态定义，都能有状态转移方程，因此，状态定义决定了该DP方法能否实现
>```
> 
> 2. 初始条件的设置： Dp本质还是迭代，总要有一个迭代的初值。
> 
> 3. 特殊处理小size的问题：有些情况，由于size太小，没法带入转移方程中。
> 
> 根据该问题，依次回答上述问题：
> 
> a. 大问题与小问题的关系
> ```
>  1）状态定义：我们定义max_profit为第i天的最大收益
>  2）状态转移方程：
>  第i天的最大收益和第i-1天的最大收益之间的关系：
>      i) 最大收益不是第i天抛出的，                        ---最大收益和第i天的价格无关
>      ii）最大收益是在第i-1天前某天买入的，并在第i天抛出的，  ---与第i天的价格有关
> 
>  因此第i天的最大收益等于：第i天抛出所造成的最大收益 和 第i-1天之前的最大收益 中的最大值
>  即：
>  前i天的最大收益 = max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格}
>  其中：
>  前i-1天中的最小价格需时时更新并记录
> ```
>  b. 初始条件：
>  ```
>  min 和 max_profit
>  min可以等于第一天的price
>  max_profit可以等于0， 因为最大收益的最小值就是0， 用人话叫，最低也不能赔了
> ```
>  c. 小于最小问题的特殊情况： 当list的长度为0 和 1 时， 没有办法带入转移公式中，需要特殊处理。



***

```
执行结果： 通过
执行用时 : 96 ms, 在所有 JavaScript 提交中击败了34.21%的用户
内存消耗 : 35.3 MB, 在所有 JavaScript 提交中击败了87.29%的用户
```

```javascript
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    if (prices.length === 0) {
        return 0
    }
    var minVal = prices[0]
    var maxVal = 0
    for (var i = 0; i < prices.length; i++) {
        if(prices[i] < minVal) {
            minVal = prices[i]
        } 
        if(prices[i] - minVal > maxVal) {
            maxVal = prices[i] - minVal
        } 
    }
    // console.log(minVal, maxVal)
    return maxVal
};
```