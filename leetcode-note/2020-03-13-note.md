# LeetCode笔记

## 【2020.03.13】  169. 多数元素

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

示例 1:
```
输入: [3,2,3]
输出: 3
```
示例 2:
```
输入: [2,2,1,1,1,2,2]
输出: 2
```

*** 

今天这道题，体感上非常简单的一道题了

直接桶计数完事

看下答案：

这道题有个限制就是当复杂度大于O(n^2)的时候会超时，这里也就不适合用枚举法这种暴力做法了

1、 使用hash计数（也就是我这种解法）空间复杂度O(n) 时间复杂度O(n)


2、 排序。下标为n/2的数字一定为多数元素。两种极端情况下（指多数元素是最大值或者最小值），多数元素能覆盖到n/2这个位置。 空间复杂度O(logn) 时间复杂度O(nlogn)

3、 随机化：若多数元素占数组的1/2时，第一次就选中目标的概率是1/2（选中后直接计数，查看是否为多数元素（也就是值大于等于n/2））；包含上一次，第二次找到的概率为1/4，以此类推，期望就是i/(2^i)的和（i为1到n），计算出来期望是2。这样的话平均的时间复杂度是O(n)，而空间复杂度则为O(1)

4、 分治： 思考下题干，可以很容易的发现：如果a是数组nums的众数，如果我们将nums分成两部分，那么a必定是至少一部分的众数。可以用反证法去证明这个结论。

应用到分治法的话，就是一层一层分割数组，当数组只有一个数的时候，这个数就是当前数组的多数元素。如果被合并时，如果两个区间的多数元素的值一样的话，那这个数就是当前区间的多数元素。否则的话就需要比较当前数组的数字出现的次数。（很像归并算法）空间复杂度O(nlogn) 时间复杂度O(nlogn)

5、 Boyer-Moore 投票算法： 如果把众数看作1，而其他数看作-1，那么整体的和就是大于0的。

这个算法和分治的十分相似。

维护一个候选众数target和一个票数count，初始值分别为null和0。当对nums列表进行遍历时，如果当前候选和当前遍历值不一样时，count减去1，相同时则加上1（遍历刚开始时，target会被赋值为第一个遍历值，并且count会加上1）。

证明： 假设一个最极端的情况： 众数出现次数刚好是(n/2) + 1，那其他数字的出现的次数为（n/2）-1，也就是众数数量要比其他数字大1或者2（当n为奇数时大1，当n为偶数时大于2，这里的n/2会自动取整），如果一个众数与一个非众数抵消的话，那最后会剩下一或者两个众数

时间复杂度O(n) 空间复杂度O(1)


Extra、 把问题转换成求第K大问题。在这里就是快排求第K大。（还没学第k大怎么求，先摸了）


***

```
执行结果： 通过
执行用时 : 76 ms, 在所有 JavaScript 提交中击败了68.30%的用户
内存消耗 : 38.3 MB, 在所有 JavaScript 提交中击败了13.88%的用户
```

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
    var len = nums.length
    let tank = {}
    nums.map(item => {
        if (tank[item] === undefined) {
            tank[item] = 1
        } else {
            tank[item] += 1
        }
    })
    let max = 0
    let target = null
    // console.log(tank)
    for (let i in tank) {
        if (tank[i] > max) {
            // console.log(tank[i])
            max =  tank[i]
            target = i
        }
    }
    return target
};
```


